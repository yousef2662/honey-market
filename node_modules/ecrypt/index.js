const { reference, asciiReference } = require('./data')
function getKeyByValue(object, value) {
  return Object.keys(object).find(key => object[key] === value);
}

class Ecrypt {
  constructor(min, max, salt) {
    this.min = min || 33;
    this.max = max || 126;
    this.salt = salt || 10;
    this.token = "";
    this.hash = "";
    this.maxAttempt = 3;
    this.attempt = 0;
  }
  generatetoken(word) {
    const { min } = this
    let securityString = "";
    for (let i = 0; i < word.length; i++) {
      const key = Math.floor(Math.random() * 93) + min
      securityString += asciiReference[key];
    }
    return securityString
  }
  encrypt(word) {
    this.token = this.generatetoken(word)
    const tokenArray = [...this.token];
    this.hash = this.createHash(word, tokenArray);
  }
  createHash(word, tokenArray) {
    let hash = "";
    const { min } = this;
    tokenArray.forEach((key, idx) => {
      let securityKey = getKeyByValue(asciiReference, key);
      let wordKey = getKeyByValue(asciiReference, word[idx]);
      let hashKey = min;
      (!wordKey) ? hashKey += parseInt(securityKey) : hashKey = parseInt(wordKey) + parseInt(securityKey);
      hash += this.rotateAscii(hashKey)
    })
    return hash;
  }
  async compare(word, token) {
    const { hash, maxAttempt, attempt } = this
    const tokenArray = [...token];
    let compareHash = this.createHash(word, tokenArray);
    if (hash === compareHash)
      return { success: 100, message: 'Ecryption Broken' }
    this.attempt++;
    return { error: 300, message: `Attempt ${attempt}, timeouts will occur after every attempt` };
  }
  isTokenLargerThanHash() {
    const { token, salt } = this
    if (token.length > salt * 10)
      return true;
    return false;
  }
  rotateAscii(stringKey) {
    const { max, min } = this;
    if (stringKey <= max) {
      return asciiReference[parseInt(stringKey)]
    } else {
      let percentage = (parseInt(stringKey) % parseInt(max))
      if (percentage < min)
        percentage += min
      return asciiReference[percentage]
    }
  }
}
const ecrypt = (token, target) => {
  const rotateAscii = (...charKeys) => {
    console.log(charKeys)
    const min = 33, max = 126;
    const keys = [...charKeys];
    const total = keys.reduce((accumulator, currentValue) => accumulator + parseInt(currentValue), 0)
    if (total <= max) {
      return asciiReference[total];
    } else {
      let percentage = (parseInt(total) % parseInt(max)) + min
      while (percentage > max) {
        percentage = (parseInt(total) % percentage) + min;
      }
      return asciiReference[percentage]
    }
  }

  const compareTokenAndTarget = (token, word) => {
    if (token.length < word.length)
      return { array: [...word], merge: [...token], length: token.length };
    return { array: [...token], merge: [...word], length: token.length };
  }

  const merge = (response) => {
    const { array, merge, length } = response;
    let counter = 0;
    const keys = [];
    array.forEach(item => {
      if (counter === length)
        counter = 0;
      const mergeKey = merge[counter] || 0;
      if (!keys[counter])
        keys.push(rotateAscii(reference[item], reference[mergeKey]));
      else
        keys[counter] = (rotateAscii(reference[item], reference[mergeKey], reference[keys[counter]]));
      counter++;
    })
    return keys.join('')
  }

  const response = compareTokenAndTarget(token, target)
  return merge(response)
}

module.exports = { Ecrypt, ecrypt };
